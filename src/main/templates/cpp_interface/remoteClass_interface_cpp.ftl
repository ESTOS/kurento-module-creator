${remoteClass.name}.cpp
/* Autogenerated with kurento-module-creator */

#include "${remoteClass.name}.hpp"
#include <mutex>

<#list module.code.implementation["cppNamespace"]?split("::") as namespace>
namespace ${namespace}
{
</#list>

static std::vector<std::string> hierarchy${remoteClass.name};
std::once_flag initFlag${remoteClass.name};

static void
initHierarchy ()
{
<#list typeHierarchy(remoteClass) as hierarchy>
  hierarchy${remoteClass.name}.emplace_back("${hierarchy}");
</#list>
}

const std::vector<std::string> &
${remoteClass.name}::getHierarchy () const
{
  std::call_once (initFlag${remoteClass.name},initHierarchy);
  return hierarchy${remoteClass.name};
}

const std::string&
${remoteClass.name}::getType () const {
  static std::string typeName = "${remoteClass.name}";

  return typeName;
}

const std::string&
${remoteClass.name}::getQualifiedType () const {
  static std::string qualifiedTypeName = getModule() + "." + getType();

  return qualifiedTypeName;
}

const std::string&
${remoteClass.name}::getModule () const {
  static std::string moduleName =  <#if module.name == "core" || module.name == "elements" || module.name == "filters">"kurento"<#else>"${module.name}"</#if>;

  return moduleName;
}

<#list module.code.implementation["cppNamespace"]?split("::")?reverse as namespace>
} /* ${namespace} */
</#list>
